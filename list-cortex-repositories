#!/usr/bin/env bash
set -Eeuo pipefail

# Default configuration
OWNER_TAG="mighty-llamas-squad"
OUTPUT_FILE="cortex_repos.csv"
BASE_URL="https://api.getcortexapp.com/api/v1/catalog"
PAGE_SIZE=250
QUIET=false

usage() {
  cat <<EOF
Usage: $(basename "$0") [--owner-tag <value>] [--output-file <path>] [--base-url <url>] [--quiet] [--help]

Fetch unique Git repositories from Cortex for a given owner tag and export as CSV.

Options:
  -o, --owner-tag      Owner tag to filter by (default: ${OWNER_TAG})
  -f, --output-file    Output CSV file path (default: ${OUTPUT_FILE})
  -u, --base-url       Base API URL (default: ${BASE_URL})
  -q, --quiet          Quiet mode (do not print repository names to stdout)
  -h, --help           Show this help and exit

Auth:
  The script expects the environment variable CORTEX_API_TOKEN to be set.
  If it is not set, you will be securely prompted to paste it (input hidden).

Output:
  CSV columns: "repo name","repo link","entity name","entity description"
EOF
}

# Ensure an option receives an accompanying value
require_option_argument() {
  local option_name="$1"
  local option_value="$2"

  if [[ -z "${option_value}" ]]; then
    echo "Error: Option ${option_name} requires an argument." >&2
    usage
    exit 2
  fi
}

# Parse CLI options with support for short and long forms
while [[ $# -gt 0 ]]; do
  case "$1" in
    -o|--owner-tag)
      require_option_argument "$1" "${2-}"
      OWNER_TAG="$2"
      shift 2
      ;;
    -f|--output-file)
      require_option_argument "$1" "${2-}"
      OUTPUT_FILE="$2"
      shift 2
      ;;
    -u|--base-url)
      require_option_argument "$1" "${2-}"
      BASE_URL="$2"
      shift 2
      ;;
    -q|--quiet)
      QUIET=true
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    --)
      shift
      break
      ;;
    -* )
      echo "Error: Invalid option $1" >&2
      usage
      exit 2
      ;;
    * )
      echo "Error: Unexpected argument $1" >&2
      usage
      exit 2
      ;;
  esac
done

# Dependencies check
require_command() { command -v "$1" >/dev/null 2>&1 || { echo "Error: required command '$1' not found in PATH." >&2; exit 1; }; }
require_command curl
require_command jq

# Read token from env or prompt securely
: "${CORTEX_API_TOKEN:=}"
if [[ -z "${CORTEX_API_TOKEN}" ]]; then
  echo -n "Enter Cortex API token: " >&2
  # shellcheck disable=SC2162
  read -rs CORTEX_API_TOKEN
  echo >&2
fi
if [[ -z "${CORTEX_API_TOKEN}" ]]; then
  echo "Error: CORTEX_API_TOKEN is required." >&2
  exit 1
fi

# Temporary files and cleanup
RESPONSE_TEMPORARY_FILE="$(mktemp -t cortex_resp.XXXXXX.json)"
ENTITIES_TEMPORARY_DIRECTORY="$(mktemp -d -t cortex_entities.XXXXXX)"
COMBINED_TEMPORARY_FILE="$(mktemp -t cortex_combined.XXXXXX.json)"
trap 'rm -f "$RESPONSE_TEMPORARY_FILE" "$COMBINED_TEMPORARY_FILE"; rm -rf "$ENTITIES_TEMPORARY_DIRECTORY"' EXIT

# Curl helper with sane defaults
fetch_json_from_api() {
  local url="$1"
  curl --fail --silent --show-error \
       --retry 3 --retry-delay 1 --retry-connrefused \
       -H "Authorization: Bearer ${CORTEX_API_TOKEN}" \
       -H "Accept: application/json" \
       "$url"
}

# Build common query and fetch first page
COMMON_QUERY_PARAMETERS="owners=$(printf '%s' "$OWNER_TAG" | jq -sRr @uri)&types=service&includeOwners=true&pageSize=${PAGE_SIZE}"
FIRST_PAGE_URL="${BASE_URL}?${COMMON_QUERY_PARAMETERS}&page=0"

if ! fetch_json_from_api "$FIRST_PAGE_URL" > "$RESPONSE_TEMPORARY_FILE"; then
  echo "Error: Failed to fetch page 0 from Cortex API." >&2
  exit 1
fi

# Determine total pages
TOTAL_PAGE_COUNT="$(jq -r '(.totalPages // 1) | tonumber' "$RESPONSE_TEMPORARY_FILE" 2>/dev/null || echo 1)"
if ! [[ "$TOTAL_PAGE_COUNT" =~ ^[0-9]+$ ]]; then
  echo "Error: Invalid totalPages value from API." >&2
  exit 1
fi

jq -c '.entities // []' "$RESPONSE_TEMPORARY_FILE" > "${ENTITIES_TEMPORARY_DIRECTORY}/entities_0.json"

# Loop remaining pages
if (( TOTAL_PAGE_COUNT > 1 )); then
  for (( PAGE_NUMBER=1; PAGE_NUMBER< TOTAL_PAGE_COUNT; PAGE_NUMBER++ )); do
    PAGE_URL="${BASE_URL}?${COMMON_QUERY_PARAMETERS}&page=${PAGE_NUMBER}"
    if ! fetch_json_from_api "$PAGE_URL" > "$RESPONSE_TEMPORARY_FILE"; then
      echo "Error: Failed to fetch page ${PAGE_NUMBER} from Cortex API." >&2
      exit 1
    fi
    jq -c '.entities // []' "$RESPONSE_TEMPORARY_FILE" > "${ENTITIES_TEMPORARY_DIRECTORY}/entities_${PAGE_NUMBER}.json"
  done
fi

# Combine all entities into one array
jq -s 'add' "${ENTITIES_TEMPORARY_DIRECTORY}/"entities_*.json > "$COMBINED_TEMPORARY_FILE"

# Extract and deduplicate unique repos
jq -r '
  def normalise_link(g):
    if (g.repositoryUrl // "") != "" then g.repositoryUrl
    elif ((g.provider // "") == "github") and ((g.repository // "") != "") then "https://github.com/" + (g.repository)
    else ""
    end;

  map(select(.git != null and ((.git.repositoryUrl != null) or (.git.repository != null))))
  | map({
      repo:         (.git.repository // ""),
      link:         normalise_link(.git),
      entity:       (.name // ""),
      description:  (.description // ""),
      key:          ((.git.repositoryUrl // .git.repository) // "")
    })
  | unique_by(.key)
  | sort_by(.repo)
  | (["repo name","repo link","entity name","entity description"]),
    (.[] | [ .repo, .link, .entity, .description ])
  | @csv
' "$COMBINED_TEMPORARY_FILE" > "$OUTPUT_FILE"

# Print repos to stdout (unless quiet)
if [[ "$QUIET" == false ]]; then
  echo "Repositories for owner '${OWNER_TAG}':"
  jq -r '
    map(select(.git != null and ((.git.repositoryUrl != null) or (.git.repository != null))))
    | map(((.git.repository) // ""))
    | unique | sort | .[]
  ' "$COMBINED_TEMPORARY_FILE"
fi

# Confirm write
WRITTEN_LINE_COUNT="$(wc -l < "$OUTPUT_FILE" | tr -d '[:space:]')"
if [[ "$WRITTEN_LINE_COUNT" -lt 1 ]]; then
  echo "Warning: No repositories found for owner tag '${OWNER_TAG}'. Wrote an empty file at ${OUTPUT_FILE}." >&2
else
  echo "Success: Wrote ${WRITTEN_LINE_COUNT} line(s) to '${OUTPUT_FILE}'."
fi
