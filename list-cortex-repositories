#!/usr/bin/env bash
set -Eeuo pipefail

# Default configuration
OWNER_TAG="${CORTEX_OWNER_TAG:-}"
OUTPUT_FILE="cortex_repos.csv"
BASE_URL="https://api.getcortexapp.com/api/v1/catalog"
PAGE_SIZE=250
QUIET=false

usage() {
  cat <<EOF
Usage: $(basename "$0") -o owner_tag [-f output_csv] [-u base_url] [-q] [-h]

Fetch unique Git repositories from Cortex for a given owner tag and export as CSV.

Options:
  -o  Owner tag to filter by (required unless CORTEX_OWNER_TAG is set)
  -f  Output CSV file path (default: ${OUTPUT_FILE})
  -u  Base API URL (default: ${BASE_URL})
  -q  Quiet mode (do not print repository names to stdout)
  -h  Show this help and exit

Auth:
  The script expects the environment variable CORTEX_API_TOKEN to be set.
  If it is not set, you will be securely prompted to paste it (input hidden).

Owner tag:
  Provide the owner tag with -o or set the environment variable CORTEX_OWNER_TAG.

Output:
  CSV columns: "repo name","repo link","entity name","entity description"
EOF
}

# Parse CLI options with getopts
while getopts ":o:f:u:qh" opt; do
  case "$opt" in
    o) OWNER_TAG="${OPTARG}" ;;
    f) OUTPUT_FILE="${OPTARG}" ;;
    u) BASE_URL="${OPTARG}" ;;
    q) QUIET=true ;;
    h) usage; exit 0 ;;
    \?) echo "Error: Invalid option -$OPTARG" >&2; usage; exit 2 ;;
    :)  echo "Error: Option -$OPTARG requires an argument." >&2; usage; exit 2 ;;
  esac
done

if [[ -z "${OWNER_TAG}" ]]; then
  echo "Error: owner tag is required. Set CORTEX_OWNER_TAG or pass -o." >&2
  usage
  exit 2
fi

# Dependencies check
require_command() { command -v "$1" >/dev/null 2>&1 || { echo "Error: required command '$1' not found in PATH." >&2; exit 1; }; }
require_command curl
require_command jq

# Read token from env or prompt securely
: "${CORTEX_API_TOKEN:=}"
if [[ -z "${CORTEX_API_TOKEN}" ]]; then
  echo -n "Enter Cortex API token: " >&2
  # shellcheck disable=SC2162
  read -rs CORTEX_API_TOKEN
  echo >&2
fi
if [[ -z "${CORTEX_API_TOKEN}" ]]; then
  echo "Error: CORTEX_API_TOKEN is required." >&2
  exit 1
fi

# Temporary files and cleanup
RESPONSE_TEMPORARY_FILE="$(mktemp -t cortex_resp.XXXXXX.json)"
ENTITIES_TEMPORARY_DIRECTORY="$(mktemp -d -t cortex_entities.XXXXXX)"
COMBINED_TEMPORARY_FILE="$(mktemp -t cortex_combined.XXXXXX.json)"
trap 'rm -f "$RESPONSE_TEMPORARY_FILE" "$COMBINED_TEMPORARY_FILE"; rm -rf "$ENTITIES_TEMPORARY_DIRECTORY"' EXIT

# Curl helper with sane defaults
fetch_json_from_api() {
  local url="$1"
  curl --fail --silent --show-error \
       --retry 3 --retry-delay 1 --retry-connrefused \
       -H "Authorization: Bearer ${CORTEX_API_TOKEN}" \
       -H "Accept: application/json" \
       "$url"
}

# Build common query and fetch first page
COMMON_QUERY_PARAMETERS="owners=$(printf '%s' "$OWNER_TAG" | jq -sRr @uri)&types=service&includeOwners=true&pageSize=${PAGE_SIZE}"
FIRST_PAGE_URL="${BASE_URL}?${COMMON_QUERY_PARAMETERS}&page=0"

if ! fetch_json_from_api "$FIRST_PAGE_URL" > "$RESPONSE_TEMPORARY_FILE"; then
  echo "Error: Failed to fetch page 0 from Cortex API." >&2
  exit 1
fi

# Determine total pages
TOTAL_PAGE_COUNT="$(jq -r '(.totalPages // 1) | tonumber' "$RESPONSE_TEMPORARY_FILE" 2>/dev/null || echo 1)"
if ! [[ "$TOTAL_PAGE_COUNT" =~ ^[0-9]+$ ]]; then
  echo "Error: Invalid totalPages value from API." >&2
  exit 1
fi

jq -c '.entities // []' "$RESPONSE_TEMPORARY_FILE" > "${ENTITIES_TEMPORARY_DIRECTORY}/entities_0.json"

# Loop remaining pages
if (( TOTAL_PAGE_COUNT > 1 )); then
  for (( PAGE_NUMBER=1; PAGE_NUMBER< TOTAL_PAGE_COUNT; PAGE_NUMBER++ )); do
    PAGE_URL="${BASE_URL}?${COMMON_QUERY_PARAMETERS}&page=${PAGE_NUMBER}"
    if ! fetch_json_from_api "$PAGE_URL" > "$RESPONSE_TEMPORARY_FILE"; then
      echo "Error: Failed to fetch page ${PAGE_NUMBER} from Cortex API." >&2
      exit 1
    fi
    jq -c '.entities // []' "$RESPONSE_TEMPORARY_FILE" > "${ENTITIES_TEMPORARY_DIRECTORY}/entities_${PAGE_NUMBER}.json"
  done
fi

# Combine all entities into one array
jq -s 'add' "${ENTITIES_TEMPORARY_DIRECTORY}/"entities_*.json > "$COMBINED_TEMPORARY_FILE"

# Extract and deduplicate unique repos
jq -r '
  def normalise_link(g):
    if (g.repositoryUrl // "") != "" then g.repositoryUrl
    elif ((g.provider // "") == "github") and ((g.repository // "") != "") then "https://github.com/" + (g.repository)
    else ""
    end;

  map(select(.git != null and ((.git.repositoryUrl != null) or (.git.repository != null))))
  | map({
      repo:         (.git.repository // ""),
      link:         normalise_link(.git),
      entity:       (.name // ""),
      description:  (.description // ""),
      key:          ((.git.repositoryUrl // .git.repository) // "")
    })
  | unique_by(.key)
  | sort_by(.repo)
  | (["repo name","repo link","entity name","entity description"]),
    (.[] | [ .repo, .link, .entity, .description ])
  | @csv
' "$COMBINED_TEMPORARY_FILE" > "$OUTPUT_FILE"

# Print repos to stdout (unless quiet)
if [[ "$QUIET" == false ]]; then
  echo "Repositories for owner '${OWNER_TAG}':"
  jq -r '
    map(select(.git != null and ((.git.repositoryUrl != null) or (.git.repository != null))))
    | map(((.git.repository) // ""))
    | unique | sort | .[]
  ' "$COMBINED_TEMPORARY_FILE"
fi

# Confirm write
WRITTEN_LINE_COUNT="$(wc -l < "$OUTPUT_FILE" | tr -d '[:space:]')"
if [[ "$WRITTEN_LINE_COUNT" -lt 1 ]]; then
  echo "Warning: No repositories found for owner tag '${OWNER_TAG}'. Wrote an empty file at ${OUTPUT_FILE}." >&2
else
  echo "Success: Wrote ${WRITTEN_LINE_COUNT} line(s) to '${OUTPUT_FILE}'."
fi
